{% load static %} {% load sass_tags %}

<div
  class="chart-container"
  style="position: relative; height: 400px; width: 100%; margin-top: 40px"
>
  <!-- ğŸ¯ Loader -->
  <div
    id="loader-{{ canvas_id }}"
    class="absolute inset-0 flex items-center justify-center bg-white/70 z-10"
    style="display: none"
  >
    <div
      class="spinner-border text-primary"
      role="status"
      style="width: 3rem; height: 3rem"
    >
      <span class="visually-hidden">Loading...</span>
    </div>
  </div>

  <!-- ğŸ¯ Canvas -->
  <canvas id="{{ canvas_id }}"></canvas>
</div>

{% block scriptcontent %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>

<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>

<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<link
  href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
  rel="stylesheet"
/>

<script>
  // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… IIFE Ù„ØªÙ†ÙÙŠØ° Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¨Ø§Ø´Ø±Ø© (ÙŠØ¹Ù…Ù„ Ù…Ø¹ AJAX Ø£ÙŠØ¶Ø§Ù‹)
  (function() {
  // ğŸ§© Ø­ÙØ¸ ÙƒÙ„ Ø§Ù„Ø´Ø§Ø±ØªØ§Øª ÙÙŠ Ø°Ø§ÙƒØ±Ø© Ø¹Ø§Ù…Ø© (Ù„ØªØ¯Ù…ÙŠØ±Ù‡Ø§ Ø£Ùˆ Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù…Ù‡Ø§)
  window.chartInstances = window.chartInstances || {};
  window.chartConfigs = window.chartConfigs || {};
    window.notifyChartRendered =
      window.notifyChartRendered ||
      function (canvasId) {
        document.dispatchEvent(
          new CustomEvent("chart:rendered", { detail: { canvasId } })
        );
      };

  // âœ… Ø­ÙØ¸ loadChartData functions Ù„ÙƒÙ„ canvas
  window.chartLoadFunctions = window.chartLoadFunctions || {};

  // =====================================================
  // ğŸ¯ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© (Canvas, Tab, Loader)
  // =====================================================

    const canvasId = "{{ canvas_id|default:chart.canvas_id }}";
  const tabName = "{{ tab.name|safe }}";

  // âœ… Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ canvas element Ù…Ø¹ retry
  function getCanvasElement() {
    const el = document.getElementById(canvasId);
    if (el && el.ownerDocument && el.ownerDocument.body.contains(el)) {
      return el;
    }
    return null;
  }

  let ctxEl = getCanvasElement();
  const loaderEl = document.getElementById("loader-" + canvasId);

  // âœ… Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† canvas Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ØŒ Ù†Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„ (Ù…ÙÙŠØ¯ Ù„Ù„Ù€ Accordion)
  if (!ctxEl) {
    console.warn("âš ï¸ [INIT] Canvas element not found yet:", canvasId, "- Will retry...");
    // âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ 500ms
    setTimeout(() => {
      ctxEl = getCanvasElement();
      if (ctxEl) {
        console.log("âœ… [INIT] Canvas found after retry, initializing chart...");
        initializeChart();
      } else {
        console.warn("âš ï¸ [INIT] Canvas still not found after retry:", canvasId);
      }
    }, 500);
    return; // âœ… Ù†Ø®Ø±Ø¬ Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¢Ù† ÙˆÙ†Ù†ØªØ¸Ø± retry
  }

  // âœ… Ù„Ø§ Ù†Ø¹Ø±Ù ctx Ù‡Ù†Ø§ - Ø³Ù†Ø­ØµÙ„ Ø¹Ù„ÙŠÙ‡ Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©

  // =====================================================
  // ğŸ”¹ 1ï¸âƒ£ Ø¯Ø§Ù„Ø© Ø±Ø³Ù… Ø§Ù„Ø´Ø§Ø±Øª Ø§Ù„Ø¯Ø§Ø¦Ø±ÙŠ Rejection
  // =====================================================
  function drawRejectionChart(chartData) {
      console.log(
        "ğŸ“ˆ [DRAW CHART] Attempting to render Rejection chart:",
        chartData
      );

      // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ canvas element (Ù…Ø¹ retry)
      let currentCtxEl = getCanvasElement();
      if (!currentCtxEl) {
        console.warn("âš ï¸ [drawRejectionChart] Canvas element not found yet:", canvasId);
        setTimeout(() => {
          currentCtxEl = getCanvasElement();
          if (currentCtxEl) {
            drawRejectionChart(chartData);
          }
        }, 300);
        return;
      }

      // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ context
      const ctx = currentCtxEl.getContext("2d");
      if (!ctx) {
        console.error("âŒ [drawRejectionChart] Cannot get 2d context from canvas:", canvasId);
        return;
      }

    // ğŸš« ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¨ÙŠØ§Ù†Ø§Øª
    if (!chartData || chartData.length === 0) {
        if (currentCtxEl && currentCtxEl.parentElement) {
          currentCtxEl.parentElement.insertAdjacentHTML('beforeend',
            "<div class='text-center text-muted mt-3'>âš ï¸ Not enough data to render this chart.</div>"
          );
        }
      return;
    }

    // ğŸ·ï¸ ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (labels & values)
    const labels = chartData.map((i) => i.month || i.label);
    const values = chartData.map((i) => {
      const val = Number(i.percentage || i.y);
      return val < 1 ? val * 100 : val;
    });

    // ğŸ§¹ ØªØ¯Ù…ÙŠØ± Ø§Ù„Ø´Ø§Ø±Øª Ø§Ù„Ù‚Ø¯ÙŠÙ… Ù„Ùˆ Ù…ÙˆØ¬ÙˆØ¯
      if (window.chartInstances[canvasId])
        window.chartInstances[canvasId].destroy();

    // âœ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¨Ù„Ø¬Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
    Chart.register(ChartDataLabels);
    Chart.register(window["chartjs-plugin-annotation"]);

    // ğŸ¨ Ø£Ù„ÙˆØ§Ù† Ù…Ù…ÙŠØ²Ø©
    // ğŸ¨ Ø£Ù„ÙˆØ§Ù† Ù…Ù…ÙŠØ²Ø© (Ø¯Ø±Ø¬Ø§Øª Ø±Ù…Ø§Ø¯ÙŠ Ã— Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­)
    const backgroundColors = [
      "#d0e7ff", // Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­ ÙˆÙˆØ§Ø¶Ø­
      "#c2e0ff", // Ø£Ø²Ø±Ù‚ Ø¨Ø§Ù‡Øª Ø¨Ø³ÙŠØ·
      "#e0e0e0", // Ø±Ù…Ø§Ø¯ÙŠ ÙØ§ØªØ­ Ø¬Ø¯Ù‹Ø§
      "#bdbdbd", // Ø±Ù…Ø§Ø¯ÙŠ Ù…ØªÙˆØ³Ø· Ù†Ø§Ø¹Ù…
      "#cfd8dc", // Ø±Ù…Ø§Ø¯ÙŠ Ø£Ø²Ø±Ù‚ Ø®ÙÙŠÙ
      "#b3e5fc", // Ø£Ø²Ø±Ù‚ Ø«Ù„Ø¬ÙŠ Ø¬Ù…ÙŠÙ„
      "#d6d6d6", // Ø±Ù…Ø§Ø¯ÙŠ Ù…ØªØ¹Ø§Ø¯Ù„
    ];

    // ğŸ¥§ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´Ø§Ø±Øª Ø§Ù„Ø¯Ø§Ø¦Ø±ÙŠ
    const rejectionChart = new Chart(ctx, {
      type: "pie",
      data: {
        labels: labels,
          datasets: [
            {
          label: "Rejection %",
          data: values,
          backgroundColor: backgroundColors.slice(0, values.length),
          borderWidth: 2,
          borderColor: "#fff",
          hoverOffset: 10,
            },
          ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: "0%", // Ø¯Ø§Ø¦Ø±Ø© ÙƒØ§Ù…Ù„Ø© (Ù…Ø´ Ø¯ÙˆÙ†Ø§Øª)
        layout: { padding: { top: 20, bottom: 20 } },
          animation: {
            animateRotate: true,
            duration: 1200,
            easing: "easeOutQuart",
          },
        plugins: {
          legend: { display: false }, // ğŸ”• Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù„ÙŠØ¨Ù„Ø§Øª Ø£Ø³ÙÙ„ Ø§Ù„Ø´Ø§Ø±Øª
          tooltip: {
              callbacks: {
                label: (ctx) => `${ctx.label}: ${ctx.parsed.toFixed(1)}%`,
              },
          },
          datalabels: {
            display: true,
            anchor: "center",
            align: "center",
            color: "#000",
            font: { weight: "bold", size: 12 },
            backgroundColor: "rgba(255,255,255,0.9)",
            borderColor: "#888",
            borderWidth: 1,
            borderRadius: 6,
            padding: 5,
            formatter: (value) => `${value.toFixed(1)}%`,
          },
        },
      },
      plugins: [ChartDataLabels],
    });

    window.chartInstances[canvasId] = rejectionChart;
      window.notifyChartRendered(canvasId);
      console.log("âœ… [CHART DONE] Rejection Pie Chart ready");
  }

  // =====================================================
  // ğŸ§  2ï¸âƒ£ Ø¯Ø§Ù„Ø© Ø¹Ø§Ù…Ø© Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ± ÙˆØ±Ø³Ù… Ø§Ù„Ø´Ø§Ø±ØªØ§Øª
  // =====================================================
  function loadChartData() {
      // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ canvas element (Ù…Ø¹ retry)
      let currentCtxEl = getCanvasElement();
      if (!currentCtxEl) {
        console.warn("âš ï¸ [loadChartData] Canvas element not found yet:", canvasId);

        // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† canvas ÙÙŠ AccordionØŒ Ù†Ù†ØªØ¸Ø± Ø­ØªÙ‰ ÙŠÙØªØ­
        const accordionItem = document.querySelector(`canvas[id="${canvasId}"]`)?.closest('.accordion-item') ||
                              document.querySelector(`[id*="${canvasId}"]`)?.closest('.accordion-item');
        if (accordionItem) {
          const accordionButton = accordionItem.querySelector('.accordion-button');
          const accordionCollapse = accordionItem.querySelector('.accordion-collapse');

          // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Accordion Ù…ÙØªÙˆØ­Ø§Ù‹ Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ø¬Ø±Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„
          if (accordionCollapse && accordionCollapse.classList.contains('show')) {
            console.log("âœ… [loadChartData] Accordion is open, retrying...");
            setTimeout(() => {
              currentCtxEl = getCanvasElement();
              if (currentCtxEl) {
                console.log("âœ… [loadChartData] Canvas found after retry, proceeding...");
                loadChartData();
              } else {
                console.warn("âš ï¸ [loadChartData] Canvas still not found after retry");
              }
            }, 500);
          } else {
            console.log("âš ï¸ [loadChartData] Accordion is closed, waiting for open event...");
            // âœ… Ø¥Ø¶Ø§ÙØ© event listener Ù„ÙØªØ­ Accordion
            if (accordionButton) {
              const handleAccordionOpen = function() {
                setTimeout(() => {
                  currentCtxEl = getCanvasElement();
                  if (currentCtxEl) {
                    console.log("âœ… [loadChartData] Canvas found after accordion open, proceeding...");
                    loadChartData();
                  } else {
                    console.warn("âš ï¸ [loadChartData] Canvas still not found after accordion open");
                  }
                }, 500);
              };
              accordionButton.addEventListener('click', handleAccordionOpen, { once: true });
            }
          }
        } else {
          // âœ… Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† ÙÙŠ AccordionØŒ Ø¬Ø±Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„
          setTimeout(() => {
            currentCtxEl = getCanvasElement();
            if (currentCtxEl) {
              console.log("âœ… [loadChartData] Canvas found after retry (not in accordion), proceeding...");
              loadChartData();
            }
          }, 500);
        }
        return;
      }

      // âœ… ØªØ­Ø¯ÙŠØ« ctxEl
      ctxEl = currentCtxEl;

      // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† canvas Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ DOM ÙˆÙ…Ø±Ø¦ÙŠ
      if (!ctxEl.ownerDocument || !ctxEl.ownerDocument.body.contains(ctxEl)) {
        console.warn("âš ï¸ [loadChartData] Canvas not in DOM yet:", canvasId);
        setTimeout(loadChartData, 300);
        return;
      }

      // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ context
      let ctx;
      try {
        ctx = ctxEl.getContext("2d");
        if (!ctx) {
          console.error("âŒ [loadChartData] Cannot get 2d context from canvas:", canvasId);
          return;
        }
      } catch (e) {
        console.error("âŒ [loadChartData] Error getting context:", e);
        return;
      }

      if (loaderEl) {
    $(loaderEl).fadeIn(200);
      }

      // âœ… Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ø§Ù„Ù€ context (chart_data)
      try {
        const chartDataRaw = {{ chart_data_json|safe|default:"[]" }};
        console.log("ğŸ” [DEBUG] Canvas ID:", canvasId);
        console.log("ğŸ” [DEBUG] Raw chart_data_json type:", typeof chartDataRaw);
        console.log("ğŸ” [DEBUG] Raw chart_data_json value:", chartDataRaw);
        console.log("ğŸ” [DEBUG] chart_data_json length:", chartDataRaw ? (typeof chartDataRaw === 'string' ? chartDataRaw.length : JSON.stringify(chartDataRaw).length) : 0);

        // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‡ÙŠ array ÙˆÙ„ÙŠØ³Øª string
        let chartDataFromContext = chartDataRaw;
        if (typeof chartDataRaw === 'string') {
          try {
            chartDataFromContext = JSON.parse(chartDataRaw);
          } catch (e) {
            console.error("âŒ [DEBUG] Failed to parse chart_data_json as JSON:", e);
            chartDataFromContext = [];
          }
        }

        // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªÙˆÙØ±Ø© ÙÙŠ Ø§Ù„Ù€ contextØŒ Ø§Ø³ØªØ®Ø¯Ù…Ù‡Ø§ Ù…Ø¨Ø§Ø´Ø±Ø©
        if (chartDataFromContext && Array.isArray(chartDataFromContext) && chartDataFromContext.length > 0) {
          console.log("âœ… [DEBUG] Using chart_data from context:", chartDataFromContext);
          console.log("âœ… [DEBUG] Canvas ID:", canvasId);
          console.log("âœ… [DEBUG] Datasets count:", chartDataFromContext.length);
          console.log("âœ… [DEBUG] Datasets names:", chartDataFromContext.map(ds => ds.name || 'N/A'));
          if (loaderEl) {
            $(loaderEl).fadeOut(200);
          }
          renderChartFromData({ chart_data: chartDataFromContext });
          return;
        } else {
          console.log("âš ï¸ [DEBUG] chart_data is empty or invalid:", chartDataFromContext);
          console.log("âš ï¸ [DEBUG] chart_data type:", typeof chartDataFromContext);
          console.log("âš ï¸ [DEBUG] chart_data isArray:", Array.isArray(chartDataFromContext));
        }
      } catch (e) {
        console.error("âŒ [DEBUG] Error reading chart_data_json:", e);
      }

      console.log("âš ï¸ [DEBUG] No chart_data in context, loading via AJAX for canvas:", canvasId);

      // âœ… Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ØªÙˆÙØ±Ø©ØŒ Ø§Ø­Ù…Ù‘Ù„Ù‡Ø§ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ± Ø¹Ø¨Ø± AJAX
      const monthSelectEl = document.getElementById("month-select");
      const selectedMonthValue = monthSelectEl ? monthSelectEl.value : "";
      const quarterSelectEl = document.getElementById("quarter-select");
      const selectedQuarterValue = quarterSelectEl ? quarterSelectEl.value : "";

    $.ajax({
      url: "{% url 'dashboard:upload_excel' %}",
      method: "GET",
        data: {
          tab: tabName,
          month: selectedMonthValue || "",
          quarter: selectedQuarterValue || "",
        },
      headers: { "X-Requested-With": "XMLHttpRequest" },

      success: function (res) {
        console.log("ğŸ§© DEBUG START ==========================");
        console.log("ğŸ“¦ tabName:", tabName);
        console.log("ğŸ“Š canvasId:", canvasId);
        console.log("ğŸŸ¢ RESPONSE:", res);
        console.log("ğŸ§© DEBUG END ============================");

        $(loaderEl).fadeOut(200);
          console.log("ğŸŸ¢ Received data:", res);

        if (!res.chart_data || !res.chart_data.length) {
            console.warn("âš ï¸ No chart data for tab:", tabName);
            return;
          }

          renderChartFromData(res);
        },

        error: function (err) {
          console.error("âŒ Error while loading chart:", err);
          $(loaderEl).fadeOut(200);
        },
      });
    }

    // âœ… Ø¯Ø§Ù„Ø© Ù…Ù†ÙØµÙ„Ø© Ù„Ø±Ø³Ù… Ø§Ù„Ø´Ø§Ø±Øª Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    function renderChartFromData(res) {
          // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ canvas element (Ù…Ø¹ retry)
          let currentCtxEl = getCanvasElement();
          if (!currentCtxEl) {
            console.warn("âš ï¸ [renderChartFromData] Canvas element not found yet:", canvasId);
            // âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„
            setTimeout(() => {
              currentCtxEl = getCanvasElement();
              if (currentCtxEl) {
                console.log("âœ… [renderChartFromData] Canvas found after retry, proceeding...");
                renderChartFromData(res);
              }
            }, 300);
            return;
          }

          // âœ… ØªØ­Ø¯ÙŠØ« ctxEl ÙˆØ§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ context
          ctxEl = currentCtxEl;
          const ctx = ctxEl.getContext("2d");
          if (!ctx) {
            console.error("âŒ [renderChartFromData] Cannot get 2d context from canvas:", canvasId);
          return;
        }

        Chart.register(ChartDataLabels);
        Chart.register(window["chartjs-plugin-annotation"]);

          // ğŸ”¸ For Rejection or Return & Refusal tabs, render only a pie chart
          const safeTabName = String(tabName)
            .replace(/&amp;/g, "&")
            .toLowerCase();

        if (
          safeTabName.includes("rejection") ||
          safeTabName.includes("refusal") ||
          safeTabName.includes("return")
        ) {
            console.log(
              "ğŸ¯ Identified tab as Rejection/Refusal/Return:",
              tabName
            );

            let doughnutSource = [];
          if (res.chart_data && res.chart_data.length > 0) {
            if (res.chart_data[0].dataPoints) {
                doughnutSource = res.chart_data[0].dataPoints;
            } else {
                doughnutSource = res.chart_data;
              }
            }

            const chartDataFixed = doughnutSource.map((dp) => ({
              label: dp.label || dp.month,
              y: Number(dp.y ?? dp.percentage) || 0,
              color: dp.color,
            }));

          drawRejectionChart(chartDataFixed);
          return;
        }

        // =====================================================
        // ğŸ¯ Ø§Ø³ØªØ®Ø±Ø§Ø¬ target Ø¥Ù† ÙˆØ¬Ø¯
        // =====================================================
          const targetDataset = res.chart_data.find(
            (ds) =>
              ds.name &&
              typeof ds.name === "string" &&
              ds.name.toLowerCase().includes("target")
        );

        let targetValue = null;
        if (targetDataset && targetDataset.dataPoints.length) {
            const validValues = targetDataset.dataPoints
              .map((dp) => Number(dp.y))
              .filter((v) => !isNaN(v));
          if (validValues.length)
              targetValue =
                validValues.reduce((a, b) => a + b, 0) / validValues.length;
        }

        // =====================================================
        // ğŸ§¾ ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        // =====================================================
        // ğŸ§¾ ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
          const labels = res.chart_data[0].dataPoints.map((dp) => dp.label);

        // ğŸ”¹ ÙÙ„ØªØ±Ø© Ø§Ù„Ø¯Ø§ØªØ§ Ø¹Ù„Ø´Ø§Ù† Ù…ÙŠÙƒÙˆÙ†Ø´ ÙÙŠÙ‡ ØªÙƒØ±Ø§Ø± ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø§Ø³Ù…
        const uniqueData = res.chart_data.filter(
            (v, i, a) => a.findIndex((t) => t.name === v.name) === i
          );

          console.log("ğŸ” [DEBUG] Chart data count:", res.chart_data.length);
          console.log("ğŸ” [DEBUG] Unique data count:", uniqueData.length);
          console.log(
            "ğŸ” [DEBUG] Chart data names:",
            res.chart_data.map((d) => d.name)
          );
          console.log(
            "ğŸ” [DEBUG] Unique data names:",
            uniqueData.map((d) => d.name)
          );

          // âœ… ÙÙ„ØªØ±Ø© datasets Ù„Ø¥Ø²Ø§Ù„Ø© Ø£ÙŠ dataset ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ "target" (Ù„Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø®Ø· Ø§Ù„Ù…Ø³ØªÙ‚ÙŠÙ…)
          const filteredData = uniqueData.filter(
            (kpi) => !kpi.name || !kpi.name.toLowerCase().includes("target")
          );

          // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ stacked charts
          const hasStackedCharts = filteredData.some(
            (kpi) => kpi.type === "stackedColumn100" || kpi.type === "stackedColumn"
          );

          const datasets = filteredData.map((kpi) => {
          let chartType = "bar";
            if (kpi.type === "pie" || kpi.type === "doughnut")
              chartType = "doughnut";
          else if (kpi.type === "line") chartType = "line";
          else if (kpi.type === "stackedColumn100" || kpi.type === "stackedColumn") {
              chartType = "bar";  // âœ… Chart.js ÙŠØ³ØªØ®Ø¯Ù… "bar" Ù„Ù„Ù€ stacked charts
            }

            const data = kpi.dataPoints.map((dp) => {
            const val = Number(dp.y);
            return val < 1 ? val * 100 : val;
          });

          const colors = [
              "#007fa3",
              "#00b3a6",
              "#f4c430",
              "#ef7b45",
              "#b61c3f",
              "#4a90e2",
              "#8bc34a",
              "#9c27b0",
              "#ff9800",
              "#cddc39",
            ];

            const datasetConfig = {
            label: kpi.name,
            data: data,
            type: chartType,
              backgroundColor:
                kpi.color || colors[Math.floor(Math.random() * colors.length)],
            borderRadius: 8,
            barThickness: 25,
          };

            // âœ… Ø¥Ø¶Ø§ÙØ© stack property Ù„Ù„Ù€ stacked charts
            if (kpi.type === "stackedColumn100" || kpi.type === "stackedColumn") {
              datasetConfig.stack = kpi.stack || "stack1";  // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… stack name Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ùˆ "stack1" ÙƒÙ€ default
            }

            return datasetConfig;
        });

        // ğŸ§¹ Ø­Ø°Ù Ø§Ù„Ø´Ø§Ø±Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…
          if (window.chartInstances[canvasId])
            window.chartInstances[canvasId].destroy();

        // =====================================================
        // ğŸ¨ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´Ø§Ø±Øª Ø§Ù„Ø¹Ù…ÙˆØ¯ÙŠ Ù…Ø¹ Ø®Ø· Ø§Ù„ØªØ§Ø±Ø¬Øª Ø§Ù„Ø£Ø­Ù…Ø±
        // =====================================================
        const mainType = datasets[0]?.type || "bar";

        // Ù„Ùˆ ÙÙŠÙ‡ Ø´Ø§Ø±Øª Ù‚Ø¯ÙŠÙ… Ù…Ø±Ø³ÙˆÙ… Ø¹Ù„Ù‰ Ù†ÙØ³ Ø§Ù„Ù€ canvasØŒ Ø§Ù…Ø³Ø­ÙŠÙ‡ Ù‚Ø¨Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙŠØ¯
        if (window.dynamicChartInstance) {
          window.dynamicChartInstance.destroy();
        }

        window.dynamicChartInstance = new Chart(ctx, {
          type: mainType,
          data: { labels, datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
              layout: { padding: { top: 40 } }, // âœ… ØªÙ‚Ù„ÙŠÙ„ padding Ù…Ù† 50 Ø¥Ù„Ù‰ 30 Ù„Ø±ÙØ¹ Ø¹Ù†ÙˆØ§Ù† KPI Ù„Ø£Ø¹Ù„Ù‰
            indexAxis: "x", // âœ… Ø¹Ù…ÙˆØ¯ÙŠ
            plugins: {
                legend: {
                  display: uniqueData.some((d) => d.showInLegend !== false), // âœ… Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ù€ legend Ø¥Ø°Ø§ ÙƒØ§Ù† showInLegend = false
                  position: "top",
                  labels: {
                    font: { size: 12, weight: "bold" },
                    padding: 15,
                    usePointStyle: true,
                  },
                },
                tooltip: { enabled: true }, // âœ… ØªÙØ¹ÙŠÙ„ tooltip Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
              datalabels: {
                  display: true,
                  anchor: "end",
                  align: "top",
                  offset: function(context) {
                    // âœ… Ù„Ù„Ù€ stacked chartsØŒ Ø¹Ø±Ø¶ labels ÙÙŠ Ù…Ù†ØªØµÙ ÙƒÙ„ segment Ù…Ø¹ Ø±ÙØ¹Ù‡Ø§ Ù„Ø£Ø¹Ù„Ù‰
                    if (hasStackedCharts) {
                      const datasetIndex = context.datasetIndex;
                      const dataIndex = context.dataIndex;
                      const datasets = context.chart.data.datasets;

                      // âœ… Ø­Ø³Ø§Ø¨ Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù€ stack
                      let previousSum = 0;
                      for (let i = 0; i < datasetIndex; i++) {
                        if (datasets[i].stack === datasets[datasetIndex].stack) {
                          const val = datasets[i].data[dataIndex];
                          if (val !== null && val !== undefined) {
                            previousSum += val;
                          }
                        }
                      }

                      // âœ… Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                      const currentValue = datasets[datasetIndex].data[dataIndex] || 0;

                      // âœ… Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ label ÙÙŠ Ù…Ù†ØªØµÙ segment Ø§Ù„Ø­Ø§Ù„ÙŠ
                      const segmentCenter = previousSum + (currentValue / 2);

                      // âœ… ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ø¥Ù„Ù‰ offset (Ù…Ù† Ø£Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø±Øª) Ù…Ø¹ Ø±ÙØ¹ Ø¥Ø¶Ø§ÙÙŠ
                      const chart = context.chart;
                      const yScale = chart.scales.y;
                      if (yScale) {
                        const chartTop = chart.chartArea.top;
                        const chartBottom = chart.chartArea.bottom;
                        const chartHeight = chartBottom - chartTop;
                        const maxValue = yScale.max || 100;
                        const percentageFromTop = (maxValue - segmentCenter) / maxValue;
                        const yPosition = chartTop + (chartHeight * percentageFromTop);
                        const currentY = yScale.getPixelForValue(segmentCenter);
                        // âœ… Ø±ÙØ¹ labels Ù„Ø£Ø¹Ù„Ù‰ Ø¨Ø¥Ø¶Ø§ÙØ© offset Ø³Ø§Ù„Ø¨ Ø¥Ø¶Ø§ÙÙŠ (-15)
                        return (currentY - yPosition) - 15;
                      }

                      // âœ… Fallback: Ø§Ø³ØªØ®Ø¯Ø§Ù… offset Ø«Ø§Ø¨Øª Ù…Ø¹ Ø±ÙØ¹ Ø¥Ø¶Ø§ÙÙŠ
                      return -40;  // âœ… Ø±ÙØ¹ Ù…Ù† -25 Ø¥Ù„Ù‰ -40
                    }

                    // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø£Ø¹Ù…Ø¯Ø© Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù†ÙØ³ Ø§Ù„Ø´Ù‡Ø±ØŒ Ù†ÙˆØ²Ø¹ labels Ø¨Ø´ÙƒÙ„ Ø¹Ù…ÙˆØ¯ÙŠ
                    const datasetIndex = context.datasetIndex;
                    const dataIndex = context.dataIndex;
                    const datasets = context.chart.data.datasets;

                    // âœ… Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ù„Ù†ÙØ³ Ø§Ù„Ø´Ù‡Ø± (Ù†ÙØ³ dataIndex)
                    let columnCount = 0;
                    for (let i = 0; i < datasets.length; i++) {
                      if (datasets[i].data[dataIndex] !== null && datasets[i].data[dataIndex] !== undefined) {
                        columnCount++;
                      }
                    }

                    // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø¹Ù…ÙˆØ¯ ÙˆØ§Ø­Ø¯ ÙÙ‚Ø·ØŒ Ø§Ø³ØªØ®Ø¯Ù… offset Ø¹Ø§Ø¯ÙŠ
                    if (columnCount === 1) {
                      return -25;
                    }

                    // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø£Ø¹Ù…Ø¯Ø© Ù…ØªØ¹Ø¯Ø¯Ø©ØŒ Ù†ÙˆØ²Ø¹ labels Ø¹Ù…ÙˆØ¯ÙŠØ§Ù‹
                    // Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ ÙƒÙ„ label: Ø£ÙˆÙ„ Ø¹Ù…ÙˆØ¯ -25ØŒ Ø«Ø§Ù†ÙŠ Ø¹Ù…ÙˆØ¯ -45ØŒ Ø¥Ù„Ø®
                    let currentColumnIndex = 0;
                    for (let i = 0; i < datasetIndex; i++) {
                      if (datasets[i].data[dataIndex] !== null && datasets[i].data[dataIndex] !== undefined) {
                        currentColumnIndex++;
                      }
                    }

                    // âœ… ØªÙˆØ²ÙŠØ¹ labels: ÙƒÙ„ Ø¹Ù…ÙˆØ¯ ÙŠØ¸Ù‡Ø± Ø£Ø¹Ù„Ù‰ Ù…Ù† Ø§Ù„Ø³Ø§Ø¨Ù‚
                    return -25 - (currentColumnIndex * 20);
                  },
                   backgroundColor: "rgba(173, 216, 230, 0.8)", // âœ… Ø£Ø²Ø±Ù‚ ÙØ§ØªØ­ Ø´Ø¨Ù‡ Ø§Ù„Ø¨Ø§Ø³ØªÙŠÙ„
                   borderColor: "rgba(100, 149, 237, 0.9)", // âœ… Ø¥Ø·Ø§Ø± Ø£Ø²Ø±Ù‚ Ù†Ø§Ø¹Ù…
                   borderWidth: 1,
                   borderRadius: 8, // âœ… Ø²ÙˆØ§ÙŠØ§ Ù†Ø§Ø¹Ù…Ø© ÙˆÙ…Ø³ØªØ¯ÙŠØ±Ø©
                   color: "#000", // âœ… Ù„ÙˆÙ† Ø§Ù„Ù†Øµ Ø£Ø²Ø±Ù‚ ØºØ§Ù…Ù‚ Ù„ÙŠØªÙ†Ø§Ø³Ù‚ Ù…Ø¹ Ø§Ù„Ø®Ù„ÙÙŠØ©
                   z: 10,
                   font: { weight: "bold", size: 11 },
                   padding: { top: 4, bottom: 4, left: 6, right: 6 },
                   formatter: function (value, context) {
                    // âœ… Ù„Ù„Ù€ stacked chartsØŒ Ø¹Ø±Ø¶ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„ÙØ¹Ù„ÙŠØ©
                    if (hasStackedCharts) {
                      return `${Math.round(value)}%`;
                    }
                    // âœ… Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙƒØ£Ø¹Ø¯Ø§Ø¯ ØµØ­ÙŠØ­Ø© Ø¨Ø¯ÙˆÙ† Ø¹Ù„Ø§Ù…Ø© Ø¹Ø´Ø±ÙŠØ© (Ù…Ø«Ù„ 50% ÙˆÙ„ÙŠØ³ 50.0%)
                    return `${Math.round(value)}%`;
                   },
                  listeners: {
                    draw: function (context) {
                      const ctx = context.chart.ctx;
                      ctx.shadowColor = "rgba(0,0,0,0.15)";
                      ctx.shadowBlur = 4;
                    },
                  },
                  // âœ… Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¯Ø§Ø®Ù„
                  clamp: true, // âœ… Ù…Ù†Ø¹ labels Ù…Ù† Ø§Ù„Ø®Ø±ÙˆØ¬ Ø®Ø§Ø±Ø¬ chartArea
                  clip: false, // âœ… Ø¹Ø¯Ù… Ù‚Øµ labels Ø¹Ù†Ø¯ Ø­Ø¯ÙˆØ¯ chartArea
              },
                annotation: { annotations: {} },
            },
            scales: {
              x: {
                stacked: hasStackedCharts,  // âœ… ØªÙØ¹ÙŠÙ„ stacked mode Ù„Ù„Ù€ stacked charts
                ticks: {
                  display: true,
                  font: { weight: "bold", size: 13 },
                },
                grid: { display: false },
              },
              y: {
                stacked: hasStackedCharts,  // âœ… ØªÙØ¹ÙŠÙ„ stacked mode Ù„Ù„Ù€ stacked charts
                display: false, // âœ… Ø¯Ù‡ Ø§Ù„Ù„ÙŠ ÙŠØ®ÙÙŠ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ù…Ù† 0 Ø¥Ù„Ù‰ 100
                grid: { display: false },
                max: hasStackedCharts ? 100 : undefined,  // âœ… ØªØ­Ø¯ÙŠØ¯ max Ø¥Ù„Ù‰ 100 Ù„Ù„Ù€ stacked charts (100%)
              },
            },
          },
          plugins: [ChartDataLabels],
        });

        window.chartInstances[canvasId] = window.dynamicChartInstance;

          // âœ… Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ø­ØªÙ‰ ÙŠØªÙ… Ø±Ø³Ù… Ø§Ù„Ø´Ø§Ø±Øª Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ù‚Ø¨Ù„ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ chartArea
          console.log(`ğŸ” [Chart] Updating chart for ${canvasId}`);
          window.dynamicChartInstance.update();

          // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… setTimeout Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† .then() Ù„Ø£Ù† update() Ù‚Ø¯ Ù„Ø§ ÙŠØ±Ø¬Ø¹ promise
          setTimeout(function() {
            try {
            console.log(`âœ… [Chart] Chart updated, rendering target line...`);
            window.notifyChartRendered(canvasId);

            // âœ… Ø­Ø°Ù Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø´Ø§Ø±Øª (On time receiving (%) â€” Avg: 100.0%)
            const chartCanvas = document.getElementById(canvasId);
            if (!chartCanvas) {
              console.error("âŒ [renderChartFromData] Chart canvas not found:", canvasId);
              return;
            }
            const chartContainer = chartCanvas.parentElement;
            if (!chartContainer) {
              console.error("âŒ [renderChartFromData] Chart container not found for canvas:", canvasId);
              return;
            }

          // Ø§Ø­Ø°Ù Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø¥Ù† ÙˆØ¬Ø¯
          const existingTitle = document.querySelector(
            `#${canvasId}-chart-title`
          );
          if (existingTitle) {
            existingTitle.remove();
        }

        // Ø§Ø­Ø°Ù Ø£ÙŠ Ø®Ø·ÙˆØ· Ù‡Ø¯Ù Ù‚Ø¯ÙŠÙ…Ø© Ù‚Ø¨Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ø· Ø§Ù„Ø¬Ø¯ÙŠØ¯
          const existingTargetLine = document.querySelector(
            `#${canvasId}-target-line`
          );
        if (existingTargetLine) {
          existingTargetLine.remove();
        }

        // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø´Ø§Ø±Øª Ù„ÙŠØ³ ÙÙŠ Order General Information
        const isOrderGeneralInfo = chartCanvas.closest('#accordionOrderGeneral') !== null;
        const canvasIdLower = canvasId.toLowerCase();
        const isInOrderGeneral = isOrderGeneralInfo ||
                                 canvasIdLower.includes('urgent-orders') ||
                                 canvasIdLower.includes('outbound-details') ||
                                 canvasIdLower.includes('picking-accuracy') ||
                                 canvasIdLower.includes('quality-exceptions');

        // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø´Ø§Ø±Øª ÙÙŠ Order General InformationØŒ Ù„Ø§ Ù†Ø¶ÙŠÙ Ø®Ø· Ø§Ù„ØªØ§Ø±Ø¬Øª
        if (isInOrderGeneral) {
          console.log(`âš ï¸ [Target Line] Skipping target line for Order General Information chart: ${canvasId}`);
          return;
        }

        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ø· Ø§Ù„Ø£Ø­Ù…Ø±

        const targetLine = document.createElement("div");
        targetLine.id = `${canvasId}-target-line`;
        targetLine.style.position = "absolute";
        targetLine.style.left = 0;
        targetLine.style.right = 0;
        targetLine.style.borderTop = "3px dashed red";
        targetLine.style.zIndex = 10;

        // Ø§Ø­Ø³Ø¨ÙŠ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø®Ø· Ø­Ø³Ø¨ Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‡Ø¯Ù (99%)
          if (!window.dynamicChartInstance) {
            console.error("âŒ [renderChartFromData] Chart instance not found");
            return;
          }

        const chartArea = window.dynamicChartInstance.chartArea;
          if (!chartArea) {
            console.error("âŒ [renderChartFromData] Chart area not found");
            return;
          }

          // âœ… Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† y scale - Ù‚Ø¯ ÙŠÙƒÙˆÙ† "y" Ø£Ùˆ "y1" Ø£Ùˆ ØºÙŠØ± Ø°Ù„Ùƒ
          let yScale = window.dynamicChartInstance.scales["y"];
          if (!yScale) {
            // âœ… Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠ y scale
            const scales = window.dynamicChartInstance.scales;
            for (const key in scales) {
              if (key.startsWith("y")) {
                yScale = scales[key];
                break;
              }
            }
          }

          if (!yScale) {
            console.error("âŒ [renderChartFromData] Y scale not found");
            return;
          }

          // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… targetValue Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ØŒ ÙˆØ¥Ù„Ø§ Ø§Ø³ØªØ®Ø¯Ø§Ù… 99% ÙƒÙ‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
          let targetPercentage = 99; // âœ… Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©

          if (targetValue !== null && targetValue > 0) {
            targetPercentage = targetValue;
          } else {
            // âœ… Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† target ÙÙŠ datasets
            const targetDataset = datasets.find(ds =>
              ds.label && ds.label.toLowerCase().includes("target")
            );
            if (targetDataset && targetDataset.data && targetDataset.data.length > 0) {
              // âœ… Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ù‚ÙŠÙ… target
              const targetValues = targetDataset.data.filter(v => v > 0);
              if (targetValues.length > 0) {
                targetPercentage = targetValues.reduce((a, b) => a + b, 0) / targetValues.length;
              }
            }
          }

          console.log(`ğŸ” [Target Line] targetValue: ${targetValue}, targetPercentage: ${targetPercentage}`);
          console.log(`ğŸ” [Target Line] yScale min: ${yScale.min}, max: ${yScale.max}`);

          // âœ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† targetPercentage Ø¶Ù…Ù† Ù†Ø·Ø§Ù‚ yScale
          const yMin = yScale.min || 0;
          const yMax = yScale.max || 100;
          const clampedTarget = Math.max(yMin, Math.min(yMax, targetPercentage));

          console.log(`ğŸ” [Target Line] clampedTarget: ${clampedTarget}`);

          // âœ… Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ y Ù„Ù„Ø®Ø·
          let y;
          try {
            y = yScale.getPixelForValue(clampedTarget);
            console.log(`ğŸ” [Target Line] y from getPixelForValue: ${y}`);
          } catch (e) {
            console.error(`âŒ [Target Line] Error getting pixel for value:`, e);
            // âœ… Ø­Ø³Ø§Ø¨ ÙŠØ¯ÙˆÙŠ ÙƒÙ€ fallback
            const chartTop = chartArea.top;
            const chartBottom = chartArea.bottom;
            const chartHeight = chartBottom - chartTop;
            const percentageFromTop = (yMax - clampedTarget) / (yMax - yMin);
            y = chartTop + (chartHeight * percentageFromTop);
            console.log(`ğŸ” [Target Line] y calculated manually: ${y}`);
          }

          // âœ… Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø®Ø· Ø§Ù„Ù†Ø³Ø¨ÙŠ Ø¯Ø§Ø®Ù„ chartArea
          const chartTop = chartArea.top;
          const chartBottom = chartArea.bottom;
          const chartLeft = chartArea.left;
          const chartRight = chartArea.right;

          console.log(`ğŸ” [Target Line] chartArea: top=${chartTop}, bottom=${chartBottom}, left=${chartLeft}, right=${chartRight}`);
          console.log(`ğŸ” [Target Line] Final y position: ${y}`);

          // âœ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† y Ø¯Ø§Ø®Ù„ chartArea
          if (y < chartTop) y = chartTop;
          if (y > chartBottom) y = chartBottom;

        targetLine.style.top = `${y}px`;
          targetLine.style.left = `${chartLeft}px`;
          targetLine.style.width = `${chartRight - chartLeft}px`;
          targetLine.style.height = `3px`; // âœ… Ø¥Ø¶Ø§ÙØ© height Ù„Ø¶Ù…Ø§Ù† Ø¸Ù‡ÙˆØ± Ø§Ù„Ø®Ø·
          targetLine.style.display = `block`; // âœ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø®Ø· Ø¸Ø§Ù‡Ø±
          targetLine.style.zIndex = `100`; // âœ… Ø²ÙŠØ§Ø¯Ø© z-index
          targetLine.innerHTML =
            `<span style='color:red;font-weight:bold;position:absolute;right:30px;top:-30px;padding:2px 5px;border-radius:3px;'>Target ${Math.round(targetPercentage)}%</span>`;

          // âœ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† chartContainer Ù„Ù‡ position: relative
          if (window.getComputedStyle(chartContainer).position === 'static') {
        chartContainer.style.position = "relative";
          }

        chartContainer.appendChild(targetLine);

          console.log(`âœ… [Target Line] âœ…âœ…âœ… Added successfully at ${y}px, target: ${Math.round(targetPercentage)}%`);
          console.log(`âœ… [Target Line] Line element:`, targetLine);
          console.log(`âœ… [Target Line] Line style:`, {
            top: targetLine.style.top,
            left: targetLine.style.left,
            width: targetLine.style.width,
            display: targetLine.style.display,
            zIndex: targetLine.style.zIndex,
            position: targetLine.style.position,
            borderTop: targetLine.style.borderTop
          });
          console.log(`âœ… [Target Line] Chart container:`, {
            position: window.getComputedStyle(chartContainer).position,
            width: chartContainer.offsetWidth,
            height: chartContainer.offsetHeight
          });

          // âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø®Ø· Ø§Ù„ØªØ§Ø±Ø¬Øª Ø¹Ù†Ø¯ Ø¸Ù‡ÙˆØ± tab pane (Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø®Ø· ÙŠØ¸Ù‡Ø± ÙÙŠ Ø§Ù„ØªØ§Ø¨Ø§Øª)
          function redrawTargetLine() {
            try {
              if (!window.dynamicChartInstance || !chartCanvas || !chartContainer) {
                return;
              }

              // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø´Ø§Ø±Øª Ù…Ø±Ø¦ÙŠ
              const tabPane = chartCanvas.closest('.tab-pane');
              if (tabPane && !tabPane.classList.contains('show') && !tabPane.classList.contains('active')) {
                // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† tab pane ØºÙŠØ± Ù…Ø±Ø¦ÙŠØŒ Ù„Ø§ Ù†Ø±Ø³Ù… Ø§Ù„Ø®Ø· Ø§Ù„Ø¢Ù†
                console.log(`âš ï¸ [Target Line] Chart is in hidden tab, will redraw when shown`);
                return;
              }

              const chartArea = window.dynamicChartInstance.chartArea;
              if (!chartArea) {
                console.warn(`âš ï¸ [Target Line] Chart area not ready yet`);
                setTimeout(redrawTargetLine, 100);
                return;
              }

              // âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ø®Ø·
              let yScale = window.dynamicChartInstance.scales["y"];
              if (!yScale) {
                const scales = window.dynamicChartInstance.scales;
                for (const key in scales) {
                  if (key.startsWith("y")) {
                    yScale = scales[key];
                    break;
                  }
                }
              }

              if (!yScale) {
                console.warn(`âš ï¸ [Target Line] Y scale not found for redraw`);
                return;
              }

              const yMin = yScale.min || 0;
              const yMax = yScale.max || 100;
              const clampedTarget = Math.max(yMin, Math.min(yMax, targetPercentage));

              let y;
              try {
                y = yScale.getPixelForValue(clampedTarget);
              } catch (e) {
                const chartTop = chartArea.top;
                const chartBottom = chartArea.bottom;
                const chartHeight = chartBottom - chartTop;
                const percentageFromTop = (yMax - clampedTarget) / (yMax - yMin);
                y = chartTop + (chartHeight * percentageFromTop);
              }

              if (y < chartArea.top) y = chartArea.top;
              if (y > chartArea.bottom) y = chartArea.bottom;

              targetLine.style.top = `${y}px`;
              targetLine.style.left = `${chartArea.left}px`;
              targetLine.style.width = `${chartArea.right - chartArea.left}px`;

              console.log(`âœ… [Target Line] ğŸ”„ Redrawn at ${y}px`);
            } catch (error) {
              console.error(`âŒ [Target Line] Error redrawing:`, error);
            }
          }

          console.log(`ğŸ” [Target Line] Setting up redraw timers and event listeners`);

          // âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„Ø®Ø· Ø¨Ø¹Ø¯ ÙØªØ±Ø© Ù‚ØµÙŠØ±Ø© Ù„Ù„ØªØ£ÙƒØ¯
          setTimeout(function() {
            console.log(`â° [Target Line] First redraw attempt (100ms)`);
            redrawTargetLine();
          }, 100);

          setTimeout(function() {
            console.log(`â° [Target Line] Second redraw attempt (500ms)`);
            redrawTargetLine();
          }, 500);

          setTimeout(function() {
            console.log(`â° [Target Line] Third redraw attempt (1000ms)`);
            redrawTargetLine();
          }, 1000);

          // âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„Ø®Ø· Ø¹Ù†Ø¯ Ø¸Ù‡ÙˆØ± tab pane
          const tabPane = chartCanvas.closest('.tab-pane');
          if (tabPane) {
            // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Bootstrap 5 event
            tabPane.addEventListener('shown.bs.tab', function() {
              setTimeout(redrawTargetLine, 100);
            });

            // âœ… Ø£ÙŠØ¶Ø§Ù‹ Ù„Ù„Ù€ parent tab triggers
            const tabTriggers = document.querySelectorAll('button[data-bs-toggle="tab"], a[data-bs-toggle="tab"]');
            tabTriggers.forEach(trigger => {
              trigger.addEventListener('shown.bs.tab', function(event) {
                // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ù‡Ø°Ø§ Ø§Ù„Ù€ tab trigger ÙŠØªØ­ÙƒÙ… ÙÙŠ tab pane Ø§Ù„Ø°ÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø±Øª
                const targetId = event.target.getAttribute('data-bs-target');
                if (targetId && tabPane.matches(targetId)) {
                  setTimeout(redrawTargetLine, 100);
                }
                // âœ… Ø£ÙŠØ¶Ø§Ù‹ØŒ Ø¥Ø°Ø§ ÙƒØ§Ù† tab pane Ù‡Ø°Ø§ ÙŠØ¸Ù‡Ø± Ø§Ù„Ø¢Ù†
                if (tabPane.classList.contains('show') && tabPane.classList.contains('active')) {
                  setTimeout(redrawTargetLine, 100);
                }
              });
            });
          }

          // âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„Ø®Ø· Ø¹Ù†Ø¯ resize
          window.addEventListener('resize', function() {
            setTimeout(redrawTargetLine, 100);
          });

          // âœ… Ø¥Ø¶Ø§ÙØ© event listener Ù„Ù„Ù€ Accordion collapse
          const accordionItem = chartCanvas.closest('.accordion-item');
          if (accordionItem) {
            const accordionButton = accordionItem.querySelector('.accordion-button');
            if (accordionButton) {
              accordionButton.addEventListener('click', function() {
                setTimeout(function() {
                  if (!accordionButton.classList.contains('collapsed')) {
                    setTimeout(redrawTargetLine, 300);
                  }
                }, 100);
              });
            }
          }

            } catch (error) {
              console.error("âŒ [renderChartFromData] Error in setTimeout:", error);
            }
          }, 200); // âœ… Ø¥ØºÙ„Ø§Ù‚ setTimeout
  }

  // ğŸš€ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø§Ø±Øª Ø£ÙˆÙ„ Ù…Ø±Ø©
  // âœ… Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ loadChartData Ù…Ø¹ retry mechanism
  function tryLoadChart() {
    ctxEl = getCanvasElement();
    if (ctxEl) {
      console.log("âœ… [INIT] Canvas found, loading chart data for:", canvasId);
  loadChartData();
    } else {
      console.warn("âš ï¸ [INIT] Canvas not found, will retry for:", canvasId);

      // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† canvas ÙÙŠ Accordion Ù…ÙØªÙˆØ­
      const accordionItem = document.querySelector(`canvas[id="${canvasId}"]`)?.closest('.accordion-item') ||
                            document.querySelector(`[id*="${canvasId}"]`)?.closest('.accordion-item');
      if (accordionItem) {
        const accordionCollapse = accordionItem.querySelector('.accordion-collapse');
        if (accordionCollapse && accordionCollapse.classList.contains('show')) {
          // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Accordion Ù…ÙØªÙˆØ­Ø§Ù‹ØŒ Ø¬Ø±Ø¨ Ø¨Ø¹Ø¯ delay Ø£Ø·ÙˆÙ„
          console.log("âœ… [INIT] Accordion is open, will retry with longer delay");
          setTimeout(tryLoadChart, 800);
        } else {
          // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Accordion Ù…ØºÙ„Ù‚Ø§Ù‹ØŒ Ø§Ù†ØªØ¸Ø± ÙØªØ­Ù‡
          setTimeout(tryLoadChart, 500);
        }
      } else {
        // âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ù‚Ù„ÙŠÙ„
        setTimeout(tryLoadChart, 500);
      }
    }
  }

  // âœ… Ø­ÙØ¸ loadChartData function Ø¨Ø´ÙƒÙ„ Ø¹Ø§Ù… Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§Ø³ØªØ¯Ø¹Ø§Ø¡
  window.chartLoadFunctions[canvasId] = loadChartData;

  // âœ… Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø§Ø±Øª
  tryLoadChart();

  // âœ… Ø¥Ø¶Ø§ÙØ© event listener Ù„ÙØªØ­ Accordion (Ø¥Ø°Ø§ ÙƒØ§Ù† canvas ÙÙŠ Accordion)
  setTimeout(() => {
    const canvasEl = getCanvasElement();
    const accordionItem = document.querySelector(`canvas[id="${canvasId}"]`)?.closest('.accordion-item') ||
                          document.querySelector(`[id*="${canvasId}"]`)?.closest('.accordion-item');

    if (accordionItem) {
      const accordionButton = accordionItem.querySelector('.accordion-button');
      const accordionCollapse = accordionItem.querySelector('.accordion-collapse');

      // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Accordion Ù…ÙØªÙˆØ­Ø§Ù‹ Ø¨Ø§Ù„ÙØ¹Ù„ (Ø§Ù„Ø£ÙˆÙ„)ØŒ Ø¬Ø±Ø¨ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø§Ø±Øª ÙÙˆØ±Ø§Ù‹
      if (accordionCollapse && accordionCollapse.classList.contains('show')) {
        console.log("âœ… [Accordion] First accordion item is open, loading chart for:", canvasId);
        // âœ… Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ø¶Ù…Ø§Ù† ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø§Ø±Øª
        setTimeout(() => {
          const retryCanvas = getCanvasElement();
          if (retryCanvas) {
            console.log("âœ… [Accordion] Canvas found in open accordion, loading chart for:", canvasId);
            loadChartData();
          } else {
            console.warn("âš ï¸ [Accordion] Canvas not found, retrying...");
            setTimeout(() => {
              const retryCanvas2 = getCanvasElement();
              if (retryCanvas2) {
                loadChartData();
              }
            }, 500);
          }
        }, 600); // âœ… Ø²ÙŠØ§Ø¯Ø© delay Ù„Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø£ÙˆÙ„
      }

      if (accordionButton) {
        // âœ… Ø¥Ø¶Ø§ÙØ© event listener Ù„ÙØªØ­ Accordion
        accordionButton.addEventListener('click', function() {
          setTimeout(() => {
            const retryCanvas = getCanvasElement();
            if (retryCanvas) {
              console.log("âœ… [Accordion] Canvas found after open, loading chart for:", canvasId);
              loadChartData();
            } else {
              console.warn("âš ï¸ [Accordion] Canvas still not found after open for:", canvasId);
            }
          }, 500);
        });
      }
    } else if (!canvasEl) {
      // âœ… Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† ÙÙŠ Accordion ÙˆÙ„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ØŒ Ø¬Ø±Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
      setTimeout(() => {
        const retryCanvas = getCanvasElement();
        if (retryCanvas) {
          loadChartData();
        }
      }, 500);
    }
  }, 500); // âœ… Ø²ÙŠØ§Ø¯Ø© delay Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Accordion

  // âœ… Ø¥Ø¶Ø§ÙØ© event listener Ø¹Ø§Ù… Ù„Ù€ Accordion collapse events
  document.addEventListener('shown.bs.collapse', function(event) {
    const accordionBody = event.target;
    if (!accordionBody) return;

    const canvas = accordionBody.querySelector('canvas');
    if (canvas && canvas.id === canvasId) {
      console.log("âœ… [Accordion Event] Canvas found in opened accordion, loading chart for:", canvasId);
      setTimeout(() => {
        if (window.chartLoadFunctions[canvasId]) {
          window.chartLoadFunctions[canvasId]();
        } else {
          loadChartData();
        }
      }, 300);
    }
  });

  // âœ… Ù…Ø¹Ø§Ù„Ø¬Ø© Tab Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ù…ÙØªÙˆØ­ Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹ (Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ÙˆÙ„)
  setTimeout(() => {
    // âœ… Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Tab Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ù…ÙØªÙˆØ­
    const tabPanes = document.querySelectorAll('.tab-pane.show.active');
    tabPanes.forEach(tabPane => {
      const canvas = tabPane.querySelector("canvas");
      if (canvas) {
        const canvasIdTab = canvas.id;
        if (window.chartLoadFunctions && window.chartLoadFunctions[canvasIdTab]) {
          console.log("âœ… [Tab Initial] Loading chart for first open tab:", canvasIdTab);
          setTimeout(() => {
            window.chartLoadFunctions[canvasIdTab]();
          }, 500);
        }
      }
    });
  }, 1000); // âœ… delay Ø£Ø·ÙˆÙ„ Ù„Ø¶Ù…Ø§Ù† ØªØ­Ù…ÙŠÙ„ DOM Ø¨Ø§Ù„ÙƒØ§Ù…Ù„

  // ğŸ§¹ ØªØ¯Ù…ÙŠØ± Ø§Ù„Ø´Ø§Ø±Øª Ø¹Ù†Ø¯ ØºÙ„Ù‚ Ø§Ù„ØªØ§Ø¨Ø©
  $(document).on("hidden.bs.tab", "a[data-bs-toggle='tab']", function (e) {
    const targetId = $(e.target).attr("href");
    if (!targetId) return;
    const canvas = $(targetId).find("canvas")[0];
    if (!canvas) return;
    const canvasId = canvas.id;
    if (window.chartInstances[canvasId]) {
      try {
        window.chartInstances[canvasId].destroy();
        delete window.chartInstances[canvasId];
          console.log(`ğŸ§¹ Destroyed chart instance for ${canvasId}`);
      } catch (err) {
          console.warn(`âš ï¸ Failed to destroy chart (${canvasId}):`, err);
      }
    }
  });

  // â™»ï¸ Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø´Ø§Ø±Øª Ø¹Ù†Ø¯ ÙØªØ­ Ø§Ù„ØªØ§Ø¨Ø©
  $(document).on("shown.bs.tab", "a[data-bs-toggle='tab']", function (e) {
    const targetId = $(e.target).attr("href");
    if (!targetId) return;
    const canvas = $(targetId).find("canvas")[0];
    if (!canvas) return;
    const canvasId = canvas.id;
    if (!window.chartInstances[canvasId]) {
        console.log(`ğŸ” Reloading chart for tab ${canvasId}`);
      loadChartData();
    }
  });
  })(); // âœ… Ø¥ØºÙ„Ø§Ù‚ IIFE
</script>

{% endblock scriptcontent %}
